"""Intent Engine for PAI.

The core innovation: Parse → Clarify → Plan pipeline.
Transforms natural language into executable automation specs.
"""

import uuid
from typing import Any

from pydantic import BaseModel, Field

from pai.llm import LLMProvider, Message, get_provider
from pai.models import (
    Action,
    Ambiguity,
    Automation,
    AutomationStatus,
    ClarificationAnswer,
    ClarificationQuestion,
    ClarificationState,
    Connector,
    EmailAction,
    EmailClassifyAction,
    EmailCondition,
    EmailTrigger,
    Entity,
    ErrorHandler,
    FileAction,
    IntentAction,
    IntentGraph,
    IntentTrigger,
    ManualTrigger,
    MonitoringConfig,
    Trigger,
    Variable,
)


# =============================================================================
# Parse Stage Models
# =============================================================================


class ParseResult(BaseModel):
    """Result of parsing natural language into intent."""

    intent: IntentGraph
    ready_for_planning: bool = False
    needs_clarification: bool = True


# =============================================================================
# Clarify Stage Models
# =============================================================================


class ClarifyResult(BaseModel):
    """Result of clarification stage."""

    state: ClarificationState
    questions: list[ClarificationQuestion] = Field(default_factory=list)
    intent: IntentGraph  # Updated intent with answers applied


# =============================================================================
# Plan Stage Models
# =============================================================================


class PlanResult(BaseModel):
    """Result of planning stage."""

    automation: Automation
    summary: str
    warnings: list[str] = Field(default_factory=list)


# =============================================================================
# LLM Response Schemas
# =============================================================================


class ParsedTrigger(BaseModel):
    """Parsed trigger from LLM."""

    type: str
    conditions: list[dict[str, Any]] = Field(default_factory=list)
    confidence: float = Field(default=0.8, ge=0.0, le=1.0)


class ParsedAction(BaseModel):
    """Parsed action from LLM."""

    type: str
    params: dict[str, Any] = Field(default_factory=dict)
    confidence: float = Field(default=0.8, ge=0.0, le=1.0)


class ParsedAmbiguity(BaseModel):
    """Ambiguity detected during parsing."""

    field: str
    description: str
    suggested_questions: list[str] = Field(default_factory=list)


class LLMParseResponse(BaseModel):
    """Schema for LLM parse response."""

    intent_type: str = "automation"
    trigger: ParsedTrigger | None = None
    actions: list[ParsedAction] = Field(default_factory=list)
    ambiguities: list[ParsedAmbiguity] = Field(default_factory=list)
    confidence: float = Field(default=0.5, ge=0.0, le=1.0)


class LLMClarifyQuestion(BaseModel):
    """Question generated by LLM."""

    question: str = ""  # Allow empty, we'll filter
    options: list[str] = Field(default_factory=list)
    default: str | None = None
    ambiguity_field: str = ""

    model_config = {"extra": "ignore"}  # Ignore extra fields from sloppy LLM output


class LLMClarifyResponse(BaseModel):
    """Schema for LLM clarify response."""

    questions: list[dict] = Field(default_factory=list)  # Accept any dict, validate later


class LLMPlanResponse(BaseModel):
    """Schema for LLM plan response."""

    name: str
    description: str
    trigger_type: str
    trigger_config: dict[str, Any] = Field(default_factory=dict)
    actions: list[dict[str, Any]] = Field(default_factory=list)
    variables: list[dict[str, Any]] = Field(default_factory=list)
    error_handling: list[dict[str, Any]] = Field(default_factory=list)
    summary: str


# =============================================================================
# Intent Engine
# =============================================================================


class IntentEngine:
    """The Intent Engine - core of PAI.

    Transforms natural language requests into executable automations
    through a three-stage pipeline: Parse → Clarify → Plan.
    """

    def __init__(self, provider: LLMProvider | None = None):
        """Initialize the Intent Engine.

        Args:
            provider: LLM provider to use. Defaults to configured provider.
        """
        self.provider = provider or get_provider()

    # =========================================================================
    # Stage 1: Parse
    # =========================================================================

    async def parse(
        self,
        text: str,
        *,
        connectors: list[Connector] | None = None,
        entities: list[Entity] | None = None,
    ) -> ParseResult:
        """Parse natural language into an intent graph.

        Args:
            text: Natural language request from user.
            connectors: Available connectors for context.
            entities: Known entities for context.

        Returns:
            ParseResult with intent graph and ambiguities.
        """
        # Build context for the prompt
        connector_names = [c.type.value for c in connectors] if connectors else []
        entity_names = [e.name for e in entities] if entities else []

        system_prompt = self._build_parse_system_prompt(connector_names, entity_names)

        messages = [Message(role="user", content=text)]

        response = await self.provider.complete_structured(
            messages,
            LLMParseResponse,
            system=system_prompt,
            temperature=0.2,
        )

        # Convert LLM response to IntentGraph
        intent_id = f"int_{uuid.uuid4().hex[:8]}"

        # Build trigger
        trigger = None
        if response.trigger:
            trigger = IntentTrigger(
                type=response.trigger.type,
                conditions=response.trigger.conditions,
                confidence=response.trigger.confidence,
            )

        # Build actions
        actions = [
            IntentAction(
                type=a.type,
                params=a.params,
                confidence=a.confidence,
            )
            for a in response.actions
        ]

        # Build ambiguities
        ambiguities = [
            Ambiguity(
                id=f"amb_{uuid.uuid4().hex[:6]}",
                field=a.field,
                description=a.description,
                suggested_questions=a.suggested_questions,
            )
            for a in response.ambiguities
        ]

        intent = IntentGraph(
            id=intent_id,
            type=response.intent_type,  # type: ignore
            confidence=response.confidence,
            trigger=trigger,
            actions=actions,
            ambiguities=ambiguities,
            raw_input=text,
        )

        # Determine if ready for planning
        ready = len(ambiguities) == 0 and response.confidence >= 0.7

        return ParseResult(
            intent=intent,
            ready_for_planning=ready,
            needs_clarification=not ready,
        )

    def _build_parse_system_prompt(
        self,
        connectors: list[str],
        entities: list[str],
    ) -> str:
        """Build the system prompt for parsing."""
        connector_str = ", ".join(connectors) if connectors else "none connected yet"
        entity_str = ", ".join(entities) if entities else "none discovered yet"

        return f"""You are parsing a user's natural language request into a structured automation intent.

User's connected systems: {connector_str}
Known entities: {entity_str}

Analyze the user's request and output a JSON object with:
1. `intent_type`: "automation", "query", or "command"
2. `trigger`: The event that starts the automation (email, schedule, webhook, file_change, manual)
3. `actions`: List of actions to perform
4. `ambiguities`: List of unclear elements that need clarification
5. `confidence`: Overall confidence score (0-1)

Trigger types:
- "email": Triggered by incoming email (conditions: from, subject, body, attachments)
- "schedule": Triggered on a schedule (cron or interval)
- "file_change": Triggered when a file changes
- "manual": Triggered by user

Action types:
- "file.write", "file.read", "file.move": File operations
- "email.send", "email.label", "email.archive": Email operations
- "email.classify": Classify email using LLM and apply label (categories: requires_action, no_action)
- "spreadsheet.append", "spreadsheet.read": Spreadsheet operations
- "document.extract": Extract data from documents

For ambiguities, identify what's unclear and suggest specific questions.
Be specific about what's unclear. Don't assume — mark low confidence.

Important: If the user mentions "client", "project", or similar entities without specifics,
mark it as ambiguous so we can ask which specific entity they mean."""

    # =========================================================================
    # Stage 2: Clarify
    # =========================================================================

    async def clarify(
        self,
        intent: IntentGraph,
        answers: list[ClarificationAnswer] | None = None,
        *,
        entities: list[Entity] | None = None,
    ) -> ClarifyResult:
        """Generate clarification questions or apply answers.

        Args:
            intent: The parsed intent with ambiguities.
            answers: Answers to previous questions (if any).
            entities: Known entities for context.

        Returns:
            ClarifyResult with questions or updated intent.
        """
        # Initialize or update state
        state = ClarificationState(intent_id=intent.id)

        # If we have answers, apply them to the intent
        if answers:
            state.answers = answers
            state.questions_answered = len(answers)
            intent = await self._apply_answers(intent, answers)

        # Check if we still have ambiguities
        if not intent.ambiguities:
            state.ready_to_plan = True
            return ClarifyResult(
                state=state,
                questions=[],
                intent=intent,
            )

        # Generate questions for remaining ambiguities
        questions = await self._generate_questions(intent, entities)
        state.questions = questions
        state.questions_asked = len(questions)

        return ClarifyResult(
            state=state,
            questions=questions,
            intent=intent,
        )

    async def _apply_answers(
        self,
        intent: IntentGraph,
        answers: list[ClarificationAnswer],
    ) -> IntentGraph:
        """Apply clarification answers to update the intent."""
        # Map question IDs to answers
        answer_map = {a.question_id: a.answer for a in answers}

        # Remove resolved ambiguities
        resolved_fields = set()
        for q_id, answer in answer_map.items():
            # Find the ambiguity this question addressed
            for amb in intent.ambiguities:
                if q_id.startswith(amb.id) or amb.field in q_id:
                    resolved_fields.add(amb.field)
                    # Update the intent based on the answer
                    intent = self._update_intent_from_answer(intent, amb.field, answer)

        # Filter out resolved ambiguities
        intent.ambiguities = [
            a for a in intent.ambiguities if a.field not in resolved_fields
        ]

        # Recalculate confidence
        if not intent.ambiguities:
            intent.confidence = min(0.95, intent.confidence + 0.2)

        return intent

    def _update_intent_from_answer(
        self,
        intent: IntentGraph,
        field: str,
        answer: str,
    ) -> IntentGraph:
        """Update intent based on a clarification answer."""
        # Update trigger conditions if applicable
        if intent.trigger and field.startswith("trigger."):
            # Add the clarified condition
            intent.trigger.conditions.append({
                "field": field.replace("trigger.", ""),
                "value": answer,
                "clarified": True,
            })
            intent.trigger.confidence = min(1.0, intent.trigger.confidence + 0.1)

        # Update action params if applicable
        for action in intent.actions:
            if field.startswith(f"action.{action.type}"):
                param_name = field.split(".")[-1]
                action.params[param_name] = answer
                action.confidence = min(1.0, action.confidence + 0.1)

        return intent

    async def _generate_questions(
        self,
        intent: IntentGraph,
        entities: list[Entity] | None = None,
    ) -> list[ClarificationQuestion]:
        """Generate clarification questions for ambiguities."""
        if not intent.ambiguities:
            return []

        entity_str = ""
        if entities:
            by_type: dict[str, list[str]] = {}
            for e in entities:
                by_type.setdefault(e.type.value, []).append(e.name)
            entity_str = "\n".join(
                f"- {t}: {', '.join(names)}" for t, names in by_type.items()
            )

        system_prompt = f"""You are helping clarify an ambiguous automation request.

Original intent: {intent.raw_input}
Ambiguities to resolve:
{chr(10).join(f'- {a.field}: {a.description}' for a in intent.ambiguities)}

User's known entities:
{entity_str or 'None discovered yet'}

Generate clarifying questions that:
1. Are specific and actionable
2. Offer smart defaults where possible (based on known entities)
3. Can be batched (ask related questions together)
4. Reference the user's actual data when helpful

Format as questions with multiple choice answers where appropriate."""

        messages = [Message(role="user", content="Generate clarification questions")]

        response = await self.provider.complete_structured(
            messages,
            LLMClarifyResponse,
            system=system_prompt,
            temperature=0.3,
        )

        # Convert to ClarificationQuestion objects (handling malformed responses)
        questions = []
        for i, q in enumerate(response.questions):
            # Extract question text - try multiple possible field names
            question_text = (
                q.get("question")
                or q.get("text")
                or q.get("query")
                or str(list(q.values())[0]) if q else ""
            )

            # Skip if we couldn't extract a question
            if not question_text or not isinstance(question_text, str):
                continue

            amb_id = intent.ambiguities[i].id if i < len(intent.ambiguities) else f"amb_{i}"

            # Normalize options - can be strings or {label, value} objects
            raw_options = q.get("options", []) if isinstance(q.get("options"), list) else []
            options = []
            for opt in raw_options:
                if isinstance(opt, str):
                    options.append(opt)
                elif isinstance(opt, dict):
                    # Handle {label, value} or {label} format
                    options.append(opt.get("label") or opt.get("value") or str(opt))

            questions.append(
                ClarificationQuestion(
                    id=f"q_{uuid.uuid4().hex[:6]}",
                    ambiguity_id=amb_id,
                    question=question_text,
                    options=options,
                    default=q.get("default"),
                )
            )

        return questions

    # =========================================================================
    # Stage 3: Plan
    # =========================================================================

    async def plan(
        self,
        intent: IntentGraph,
        *,
        connectors: list[Connector] | None = None,
    ) -> PlanResult:
        """Generate an automation specification from a clarified intent.

        Args:
            intent: The clarified intent (no ambiguities).
            connectors: Available connectors.

        Returns:
            PlanResult with the automation spec.
        """
        if intent.ambiguities:
            raise ValueError(
                "Intent has unresolved ambiguities. Run clarify() first."
            )

        connector_str = ", ".join(
            c.type.value for c in connectors
        ) if connectors else "none"

        system_prompt = f"""You are generating an automation specification from a clarified intent.

Intent: {intent.raw_input}
Trigger: {intent.trigger.model_dump_json() if intent.trigger else 'manual'}
Actions: {[a.model_dump() for a in intent.actions]}
Available connectors: {connector_str}

Generate a complete automation spec that:
1. Is executable by our runtime
2. Handles edge cases gracefully
3. Includes appropriate error handling
4. Sets up monitoring and notifications

Output a JSON object with:
- name: Short descriptive name for the automation
- description: What this automation does
- trigger_type: email, schedule, webhook, file_change, or manual
- trigger_config: Configuration for the trigger
- actions: List of actions, each with:
  - type: The action type (e.g., "email.label", "email.classify", "file.move")
  - connector: Which connector to use (e.g., "gmail")
  - For email.label: label (the label name)
  - For email.classify: categories (list like ["requires_action", "no_action"]), category_labels (dict mapping category to Gmail label name)
  - message_id: For email actions, use "${{trigger.email.id}}" for dynamic reference
  - Other params as needed (to, subject, body, path, etc.)
- variables: Variables to extract and use
- error_handling: How to handle errors
- summary: Human-readable summary (2-3 sentences)

IMPORTANT:
- Put action parameters at the top level of each action object, not nested under "params".
- If the parsed actions include "email.classify", preserve that action type - do not convert to "email.label"."""

        messages = [Message(role="user", content="Generate automation spec")]

        response = await self.provider.complete_structured(
            messages,
            LLMPlanResponse,
            system=system_prompt,
            temperature=0.1,
        )

        # Build the Automation object
        automation = self._build_automation(response, intent)

        # Generate warnings
        warnings = self._generate_warnings(automation)

        return PlanResult(
            automation=automation,
            summary=response.summary,
            warnings=warnings,
        )

    def _build_automation(
        self,
        response: LLMPlanResponse,
        intent: IntentGraph,
    ) -> Automation:
        """Build an Automation from the LLM response."""
        auto_id = f"auto_{uuid.uuid4().hex[:8]}"

        # Build trigger
        trigger = self._build_trigger(response.trigger_type, response.trigger_config)

        # Build actions
        actions = self._build_actions(response.actions)

        # Build variables
        variables = [
            Variable(
                name=v.get("name", ""),
                type=v.get("type", "string"),
                resolved_from=v.get("resolved_from", "trigger"),
            )
            for v in response.variables
        ]

        # Build error handlers (with validation for LLM output)
        valid_actions = {"continue", "stop", "notify", "create_review_task"}
        error_handlers = []
        for e in response.error_handling:
            action = e.get("action", "notify")
            # Map common LLM outputs to valid actions
            if action not in valid_actions:
                action = "notify"  # Default fallback
            error_handlers.append(
                ErrorHandler(
                    condition=e.get("condition", "any_error"),
                    action=action,  # type: ignore
                    message=e.get("message"),
                )
            )

        return Automation(
            id=auto_id,
            name=response.name,
            description=response.description,
            status=AutomationStatus.DRAFT,
            trigger=trigger,
            variables=variables,
            actions=actions,
            error_handling=error_handlers,
            monitoring=MonitoringConfig(notify_on=["error", "success"]),
        )

    def _build_trigger(
        self,
        trigger_type: str,
        config: dict[str, Any],
    ) -> Trigger:
        """Build a Trigger from type and config."""
        if trigger_type == "email":
            conditions = []
            for cond in config.get("conditions", []):
                # LLM may use 'key' instead of 'field'
                field = cond.get("field") or cond.get("key")
                value = cond.get("value", "")

                # Skip meta-conditions like {'key': 'incoming', 'value': True}
                if field in ("incoming", "all", "any") or isinstance(value, bool):
                    continue

                # Ensure value is a string
                value = str(value) if value else ""

                # Validate field is a known email field
                valid_fields = ("from", "to", "subject", "body", "attachments")
                if field not in valid_fields:
                    continue

                conditions.append(
                    EmailCondition(
                        field=field,  # type: ignore
                        operator=cond.get("operator", "contains"),  # type: ignore
                        value=value,
                    )
                )
            return EmailTrigger(
                account=config.get("account", "default"),
                conditions=conditions,
            )
        # Default to manual trigger
        return ManualTrigger()

    def _build_actions(self, action_configs: list[dict[str, Any]]) -> list[Action]:
        """Build Action objects from config."""
        actions: list[Action] = []

        for config in action_configs:
            action_type = config.get("type", "")
            # LLM might nest params or put them at top level - check both
            params = config.get("params", {})

            if action_type.startswith("file."):
                actions.append(
                    FileAction(
                        type=action_type,  # type: ignore
                        connector=config.get("connector", params.get("connector", "")),
                        path=config.get("path", params.get("path", "")),
                        source=config.get("source", params.get("source")),
                    )
                )
            elif action_type == "email.classify":
                # Get categories from config or use defaults
                categories = config.get("categories", params.get("categories", ["requires_action", "no_action"]))
                category_labels = config.get("category_labels", params.get("category_labels", {
                    "requires_action": "Requires Action",
                    "no_action": "No Action Required",
                }))
                actions.append(
                    EmailClassifyAction(
                        connector=config.get("connector", params.get("connector", "gmail")),
                        message_id=config.get("message_id", params.get("message_id")),
                        categories=categories,
                        category_labels=category_labels,
                        prompt=config.get("prompt", params.get("prompt")),
                    )
                )
            elif action_type.startswith("email."):
                actions.append(
                    EmailAction(
                        type=action_type,  # type: ignore
                        connector=config.get("connector", params.get("connector", "gmail")),
                        to=config.get("to", params.get("to")),
                        subject=config.get("subject", params.get("subject")),
                        body=config.get("body", params.get("body")),
                        label=config.get("label", params.get("label", params.get("label_name"))),
                        message_id=config.get("message_id", params.get("message_id")),
                    )
                )
            # Add more action types as needed

        return actions

    def _generate_warnings(self, automation: Automation) -> list[str]:
        """Generate warnings about the automation."""
        warnings = []

        # Check for missing connectors
        for action in automation.actions:
            if hasattr(action, "connector") and not action.connector:
                warnings.append(
                    f"Action '{action.type}' has no connector specified"
                )

        # Check for email sends (require approval)
        for action in automation.actions:
            if isinstance(action, EmailAction) and action.type == "email.send":
                warnings.append(
                    "This automation sends emails - will require approval before each send"
                )

        return warnings


# =============================================================================
# Convenience Functions
# =============================================================================


async def parse_intent(
    text: str,
    *,
    provider: LLMProvider | None = None,
    connectors: list[Connector] | None = None,
    entities: list[Entity] | None = None,
) -> ParseResult:
    """Parse natural language into an intent graph.

    Convenience function that creates an IntentEngine and calls parse().
    """
    engine = IntentEngine(provider)
    return await engine.parse(text, connectors=connectors, entities=entities)


async def clarify_intent(
    intent: IntentGraph,
    answers: list[ClarificationAnswer] | None = None,
    *,
    provider: LLMProvider | None = None,
    entities: list[Entity] | None = None,
) -> ClarifyResult:
    """Generate clarification questions or apply answers.

    Convenience function that creates an IntentEngine and calls clarify().
    """
    engine = IntentEngine(provider)
    return await engine.clarify(intent, answers, entities=entities)


async def plan_automation(
    intent: IntentGraph,
    *,
    provider: LLMProvider | None = None,
    connectors: list[Connector] | None = None,
) -> PlanResult:
    """Generate an automation specification from a clarified intent.

    Convenience function that creates an IntentEngine and calls plan().
    """
    engine = IntentEngine(provider)
    return await engine.plan(intent, connectors=connectors)
